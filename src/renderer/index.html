<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Kerning City - Cloud Font Agent</title>
    <link rel="stylesheet" href="styles/variables.css" />
    <link rel="stylesheet" href="styles/base.css" />
    <link rel="stylesheet" href="styles/layout.css" />
    <link rel="stylesheet" href="styles/components.css" />
    <style>
      /* Fix layout overflow issues */
      .main-content {
        overflow: hidden;
      }

      .main-content__body {
        background: #ffffff;
        padding: 0;
        overflow-y: auto;
        overflow-x: hidden;
      }

      /* Font list container - NO PADDING to prevent overflow */
      .font-list {
        width: 100%;
        padding: 0 !important; /* Override components.css padding */
        box-sizing: border-box;
      }

      /* Search bar with proper margins */
      .search-bar {
        position: relative;
        width: calc(100% - 40px);
        margin: 20px 20px;
        box-sizing: border-box;
      }

      .search-bar__icon {
        position: absolute;
        left: 16px;
        top: 50%;
        transform: translateY(-50%);
        color: #86868b;
        pointer-events: none;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .search-bar__icon svg {
        width: 18px;
        height: 18px;
      }

      .search-bar__input {
        width: 100%;
        background: #e8e8ed;
        border: none;
        padding: 10px 16px 10px 40px;
        border-radius: 8px;
        font-size: 14px;
        box-sizing: border-box;
      }

      /* Provider groups with proper margins */
      .provider-group {
        margin: 0 20px 4px 20px !important;
        width: calc(100% - 40px);
        box-sizing: border-box;
      }

      .provider-group__header {
        padding: 8px 16px;
        background: transparent;
        border-radius: 0;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .provider-group__name {
        font-size: 15px;
        font-weight: 600;
        color: #1d1d1f;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      /* First part: font preview with actual font applied */
      .provider-group__name-preview {
        color: #1d1d1f;
        font-weight: 600;
        font-size: 15px;
        /* Font family will be set dynamically via inline style */
      }

      /* Second part: original name in gray */
      .provider-group__name-original {
        color: #86868b;
        font-weight: 400;
        font-size: 15px;
      }

      .provider-group__toggle {
        background: none;
        border: none;
        cursor: pointer;
        font-size: 12px;
        color: #86868b;
        padding: 4px;
      }

      .provider-group__fonts {
        padding: 0;
        border-left: 2px solid #e5e5e7;
        margin-left: 16px;
        margin-top: 4px;
        box-sizing: border-box;
      }

      /* Font items */
      .font-item {
        padding: 6px 12px;
        margin-left: 12px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: transparent;
        width: calc(100% - 12px);
        box-sizing: border-box;
        gap: 8px;
      }

      .font-item__actions {
        display: flex;
        align-items: center;
        flex-shrink: 0;
        order: 1; /* Info button first */
      }

      .font-item__info {
        flex: 1;
        min-width: 0;
        overflow: hidden;
        order: 2; /* Font name second */
      }

      .font-item__version {
        flex-shrink: 0;
        order: 3; /* Version dropdown third */
        min-width: 100px;
      }

      .font-item__toggle {
        flex-shrink: 0;
        order: 4; /* Toggle last */
      }

      .font-item__name {
        font-size: 14px;
        color: #86868b;
        font-weight: 400;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .font-item__info-btn {
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        color: #86868b;
        background: transparent;
        border-radius: 50%;
        padding: 0;
        cursor: pointer;
        flex-shrink: 0;
        border: none;
      }

      .font-item__info-btn:hover {
        background: #f5f5f7;
      }

      /* Custom Version Dropdown */
      .custom-dropdown {
        position: relative;
        width: 100%;
        min-width: 90px;
      }

      .custom-dropdown__trigger {
        background: #ffffff;
        border: 1px solid #e5e5e7;
        border-radius: 8px;
        padding: 6px 12px;
        font-size: 11px;
        color: #1d1d1f;
        cursor: pointer;
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: flex-start;
        gap: 6px;
        box-sizing: border-box;
        transition: all 0.2s ease;
        white-space: nowrap;
      }

      .custom-dropdown__trigger:hover {
        background: #f5f5f7;
      }

      .custom-dropdown__value {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        flex: 1;
      }

      .custom-dropdown__trigger-icon {
        color: #86868b;
        font-size: 10px;
        transition: transform 0.2s ease;
        flex-shrink: 0;
        order: -1;
      }

      .custom-dropdown--open .custom-dropdown__trigger-icon {
        transform: rotate(90deg);
      }

      .custom-dropdown__menu {
        position: absolute;
        top: calc(100% + 4px);
        left: 0;
        right: 0;
        background: #ffffff;
        border: 1px solid #e5e5e7;
        border-radius: 8px;
        padding: 8px;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        z-index: 1000;
        display: none;
        max-height: 200px;
        overflow-y: auto;
      }

      .custom-dropdown--open .custom-dropdown__menu {
        display: block;
      }

      .custom-dropdown__item {
        padding: 10px 14px;
        font-size: 11px;
        color: #86868b;
        cursor: pointer;
        border-radius: 8px;
        transition: all 0.2s ease;
        text-align: center;
        white-space: nowrap;
      }

      .custom-dropdown__item:hover {
        background: #f5f5f7;
      }

      .custom-dropdown__item--selected {
        background: #d4f4dd;
        color: #1d1d1f;
        font-weight: 500;
      }

      .custom-dropdown__item--selected:hover {
        background: #c5efd0;
      }

      .version-label {
        font-size: 12px;
        color: #86868b;
        padding: 4px 8px;
      }

      /* Toggle Switch - Smaller version */
      .toggle {
        position: relative;
        display: inline-block;
        width: 36px;
        height: 20px;
        flex-shrink: 0;
      }

      .toggle__input {
        opacity: 0;
        width: 0;
        height: 0;
        position: absolute;
      }

      .toggle__slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: #d1d1d6;
        transition: background 0.2s ease-out;
        border-radius: 9999px;
      }

      .toggle__slider::before {
        position: absolute;
        content: "";
        height: 16px;
        width: 16px;
        left: 2px;
        bottom: 2px;
        background: white;
        transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        border-radius: 50%;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
      }

      .toggle__input:checked + .toggle__slider {
        background: #34c759;
      }

      .toggle__input:checked + .toggle__slider::before {
        transform: translateX(16px);
      }

      /* Sidebar controls - match login page position (fixed, outside sidebar) */
      .sidebar__controls {
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 1000;
        -webkit-app-region: no-drag;
      }

      .sidebar__controls .window-controls {
        display: flex;
        gap: 8px;
      }

      /* Navigation icons */
      .nav-item {
        height: 56px;
        border-left: 3px solid transparent;
      }

      .nav-item__icon {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 24px;
        height: 24px;
      }

      .nav-item__icon svg {
        width: 20px;
        height: 20px;
        stroke-width: 1.5;
      }

      .sidebar__settings {
        margin-top: auto;
      }
    </style>
  </head>
  <body>
    <div class="app">
      <!-- Header -->
      <header class="header">
        <h1 class="header__title">Kerning City</h1>
      </header>

      <!-- Main Layout -->
      <div class="main-layout">
        <!-- Window Controls (outside sidebar, fixed position like login page) -->
        <div class="sidebar__controls">
          <div class="window-controls">
            <button
              class="window-controls__button window-controls__button--close"
            ></button>
            <button
              class="window-controls__button window-controls__button--minimize"
            ></button>
            <button
              class="window-controls__button window-controls__button--maximize"
            ></button>
          </div>
        </div>

        <!-- Sidebar -->
        <aside class="sidebar">
          <nav class="sidebar__nav">
            <button class="nav-item nav-item--active" data-nav="home">
              <span class="nav-item__icon">
                <svg
                  width="20"
                  height="20"
                  viewBox="0 0 20 20"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    d="M3 10L10 3L17 10V17H12V13H8V17H3V10Z"
                    stroke="currentColor"
                    stroke-width="1.5"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  />
                </svg>
              </span>
            </button>
            <button class="nav-item" data-nav="messages">
              <span class="nav-item__icon">
                <svg
                  width="20"
                  height="20"
                  viewBox="0 0 20 20"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    d="M17 9C17 13.4183 13.4183 17 9 17C7.5 17 6.1 16.6 5 15.9L2 17L3.1 14C2.4 12.9 2 11.5 2 10C2 5.58172 5.58172 2 10 2C14.4183 2 18 5.58172 18 10Z"
                    stroke="currentColor"
                    stroke-width="1.5"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  />
                </svg>
              </span>
            </button>
            <button class="nav-item" data-nav="cloud">
              <span class="nav-item__icon">
                <svg
                  width="20"
                  height="20"
                  viewBox="0 0 20 20"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    d="M6 14C3.79086 14 2 12.2091 2 10C2 7.79086 3.79086 6 6 6C6.17 6 6.34 6.01 6.5 6.03C7.07 3.69 9.23 2 11.8 2C14.78 2 17.2 4.42 17.2 7.4C17.2 7.47 17.2 7.54 17.19 7.61C18.21 8.09 19 9.13 19 10.33C19 12 17.67 13.33 16 13.33H6V14Z"
                    stroke="currentColor"
                    stroke-width="1.5"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  />
                </svg>
              </span>
            </button>
          </nav>
          <div class="sidebar__settings">
            <button class="nav-item" data-nav="settings">
              <span class="nav-item__icon">
                <svg
                  width="20"
                  height="20"
                  viewBox="0 0 20 20"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <circle cx="5" cy="10" r="1.5" fill="currentColor" />
                  <circle cx="10" cy="10" r="1.5" fill="currentColor" />
                  <circle cx="15" cy="10" r="1.5" fill="currentColor" />
                </svg>
              </span>
            </button>
          </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
          <div class="main-content__body" id="fontListContainer">
            <!-- Font list will be inserted here -->
          </div>
        </main>
      </div>
    </div>

    <script>
      console.log("=== SCRIPT LOADED ===");
      console.log("App loaded");
      console.log("window.fontAPI:", window.fontAPI);

      // Window controls
      document
        .querySelector(".window-controls__button--close")
        ?.addEventListener("click", () => {
          window.close();
        });

      document
        .querySelector(".window-controls__button--minimize")
        ?.addEventListener("click", () => {
          if (window.electronAPI) {
            window.electronAPI.minimize();
          }
        });

      document
        .querySelector(".window-controls__button--maximize")
        ?.addEventListener("click", () => {
          if (window.electronAPI) {
            window.electronAPI.maximize();
          }
        });

      // Application state
      let allFonts = [];
      let registeredFontIds = new Set();

      // Navigation
      document.querySelectorAll("[data-nav]").forEach((button) => {
        button.addEventListener("click", (e) => {
          const nav = e.currentTarget.dataset.nav;
          console.log("Navigation:", nav);

          document.querySelectorAll(".nav-item").forEach((item) => {
            item.classList.remove("nav-item--active");
          });

          e.currentTarget.classList.add("nav-item--active");

          if (nav !== "home") {
            alert(`${nav} 기능은 준비 중입니다.`);
          }
        });
      });

      // Search
      function setupSearch() {
        const searchInput = document.getElementById("searchInput");
        if (!searchInput) return;

        searchInput.addEventListener("input", (e) => {
          const query = e.target.value.toLowerCase();
          console.log("Search:", query);

          document.querySelectorAll(".provider-group").forEach((group) => {
            const groupName = group
              .querySelector(".provider-group__name")
              .textContent.toLowerCase();
            const fonts = group.querySelectorAll(".font-item");
            let hasVisibleFont = false;

            fonts.forEach((font) => {
              const fontName = font
                .querySelector(".font-item__name")
                .textContent.toLowerCase();
              if (
                fontName.includes(query) ||
                groupName.includes(query) ||
                query === ""
              ) {
                font.style.display = "flex";
                hasVisibleFont = true;
              } else {
                font.style.display = "none";
              }
            });

            group.style.display =
              hasVisibleFont || query === "" ? "block" : "none";
          });
        });
      }

      // Group fonts by provider and then by font family
      // Uses provider metadata from API (info.json)
      function groupFontsByProvider(fonts) {
        const groups = {};

        fonts.forEach((font) => {
          // Use provider field from API (from info.json)
          const providerId = font.provider || "unknown";
          const displayName = font.displayName || providerId;
          const previewFont = font.previewFont;

          if (!groups[providerId]) {
            groups[providerId] = {
              id: providerId,
              displayName: displayName,
              previewFont: previewFont,
              fontFamilies: {}, // Group by font family
            };
          }

          // Group by font family AND format (to separate TTF and OTF)
          const fontFamily = font.fontFamily || font.name;
          const format = font.format || "truetype";
          const formatLabel = format === "opentype" ? "OTF" : "TTF";
          // Create unique key with format
          const fontFamilyKey = `${fontFamily}-${format}`;

          if (!groups[providerId].fontFamilies[fontFamilyKey]) {
            groups[providerId].fontFamilies[fontFamilyKey] = {
              name: fontFamily,
              format: format,
              displayName: `${fontFamily} (${formatLabel})`,
              versions: {}, // Group by version
            };
          }

          // Group by version
          const version = font.version || "v1.0";
          if (
            !groups[providerId].fontFamilies[fontFamilyKey].versions[version]
          ) {
            groups[providerId].fontFamilies[fontFamilyKey].versions[version] =
              [];
          }

          groups[providerId].fontFamilies[fontFamilyKey].versions[version].push(
            font
          );
        });

        return Object.values(groups);
      }

      // Render fonts to UI
      function renderFonts(fonts) {
        console.log("=== Rendering fonts ===");
        console.log("Number of fonts to render:", fonts.length);

        const container = document.getElementById("fontListContainer");
        if (!container) {
          console.error("Font list container not found!");
          return;
        }

        const groups = groupFontsByProvider(fonts);
        console.log("Number of provider groups:", groups.length);

        let html = '<div class="font-list">';

        // Search Bar
        html += `
          <div class="search-bar">
            <span class="search-bar__icon">
              <svg width="18" height="18" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                <circle cx="9" cy="9" r="6" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M13.5 13.5L17 17" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </span>
            <input type="text" class="search-bar__input" placeholder="Search..." id="searchInput" />
          </div>
        `;

        // Provider groups
        groups.forEach((group, index) => {
          const isExpanded = index === groups.length - 1; // Last group expanded by default

          // Extract font family name from preview font file
          // Remove file extension to get the font family name
          const previewFontFamily = group.previewFont
            ? group.previewFont.replace(/\.(ttf|otf)$/i, "")
            : null;

          html += `
            <div class="provider-group" data-provider-id="${group.id}">
              <div class="provider-group__header">
                <h3 class="provider-group__name">
                  ${
                    previewFontFamily
                      ? `<span class="provider-group__name-preview" style="font-family: '${previewFontFamily}', sans-serif;">${group.displayName}</span>`
                      : ""
                  }
                  <span class="provider-group__name-original">${
                    group.displayName
                  }</span>
                </h3>
                <button class="provider-group__toggle">${
                  isExpanded ? "▲" : "▼"
                }</button>
              </div>
              <div class="provider-group__fonts" style="display: ${
                isExpanded ? "block" : "none"
              }">
          `;

          // Iterate through font families
          Object.values(group.fontFamilies).forEach((fontFamily) => {
            // Get all versions for this font family
            const versions = Object.keys(fontFamily.versions).sort().reverse(); // Latest first

            // Find if any version is currently registered
            let activeVersion = null;
            let activeFont = null;
            for (const version of versions) {
              const fontsInVersion = fontFamily.versions[version];
              for (const font of fontsInVersion) {
                if (registeredFontIds.has(font.id)) {
                  activeVersion = version;
                  activeFont = font;
                  break;
                }
              }
              if (activeVersion) break;
            }

            // Default to latest version if none is active
            const defaultVersion = activeVersion || versions[0];
            const defaultFonts = fontFamily.versions[defaultVersion];
            const defaultFont = defaultFonts[0]; // Pick first format (TTF/OTF)

            // Check if this font is enabled
            const isEnabled = activeFont
              ? registeredFontIds.has(activeFont.id)
              : false;

            // Extract font family name for styling
            const fontFamilyName = fontFamily.name
              .replace(/\s+(Regular|Bold|Light|Medium|Italic|Normal)$/i, "")
              .trim();

            // Generate unique ID for this font family (include format to separate TTF/OTF)
            const formatSuffix =
              fontFamily.format === "opentype" ? "OTF" : "TTF";
            const fontFamilyId = `${group.id}-${fontFamilyName.replace(
              /\s+/g,
              "-"
            )}-${formatSuffix}`;

            html += `
              <div class="font-item" data-font-family-id="${fontFamilyId}">
                <div class="font-item__actions">
                  <button class="font-item__info-btn" data-font-id="${
                    defaultFont.id
                  }">ⓘ</button>
                </div>
                <div class="font-item__info">
                  <div class="font-item__name" style="font-family: '${fontFamilyName}', sans-serif;">${
              fontFamily.displayName || fontFamily.name
            }</div>
                </div>
                <div class="font-item__version">
                  ${
                    versions.length > 1
                      ? `
                    <div class="custom-dropdown" data-font-family-id="${fontFamilyId}">
                      <button class="custom-dropdown__trigger" type="button">
                        <span class="custom-dropdown__trigger-icon">›</span>
                        <span class="custom-dropdown__value">${defaultVersion}</span>
                      </button>
                      <div class="custom-dropdown__menu">
                        ${versions
                          .map(
                            (v) =>
                              `<div class="custom-dropdown__item ${
                                v === defaultVersion
                                  ? "custom-dropdown__item--selected"
                                  : ""
                              }" data-value="${v}">${v}</div>`
                          )
                          .join("")}
                      </div>
                    </div>
                  `
                      : ``
                  }
                </div>
                <div class="font-item__toggle">
                  <label class="toggle" for="toggle-${fontFamilyId}">
                    <input type="checkbox" class="toggle__input" id="toggle-${fontFamilyId}" ${
              isEnabled ? "checked" : ""
            } data-font-family-id="${fontFamilyId}" data-current-version="${defaultVersion}" data-current-font-id="${
              activeFont ? activeFont.id : defaultFont.id
            }">
                    <span class="toggle__slider"></span>
                  </label>
                </div>
              </div>
            `;
          });

          html += `
              </div>
            </div>
          `;
        });

        html += "</div>";
        container.innerHTML = html;

        // Wait for DOM to be fully updated before setting up listeners
        setTimeout(() => {
          setupEventListeners();
        }, 0);
      }

      // Setup event listeners
      function setupEventListeners() {
        console.log("=== Setting up event listeners ===");
        console.log(
          "Container HTML length:",
          document.getElementById("fontListContainer").innerHTML.length
        );
        console.log(
          "Font list exists:",
          !!document.querySelector(".font-list")
        );

        setupSearch();

        // Provider group toggle
        const providerHeaders = document.querySelectorAll(
          ".provider-group__header"
        );
        console.log("Found provider headers:", providerHeaders.length);

        providerHeaders.forEach((header) => {
          header.addEventListener("click", (e) => {
            const group = e.currentTarget.closest(".provider-group");
            const fonts = group.querySelector(".provider-group__fonts");
            const toggle = group.querySelector(".provider-group__toggle");

            if (fonts.style.display === "none") {
              fonts.style.display = "block";
              toggle.textContent = "▲";
            } else {
              fonts.style.display = "none";
              toggle.textContent = "▼";
            }
          });
        });

        // Custom dropdown handlers
        const customDropdowns = document.querySelectorAll(".custom-dropdown");
        console.log("Found custom dropdowns:", customDropdowns.length);

        customDropdowns.forEach((dropdown) => {
          const trigger = dropdown.querySelector(".custom-dropdown__trigger");
          const menu = dropdown.querySelector(".custom-dropdown__menu");
          const items = dropdown.querySelectorAll(".custom-dropdown__item");
          const valueDisplay = dropdown.querySelector(
            ".custom-dropdown__value"
          );
          const fontFamilyId = dropdown.dataset.fontFamilyId;

          // Toggle dropdown open/close
          trigger.addEventListener("click", (e) => {
            e.stopPropagation();

            // Close all other dropdowns
            document.querySelectorAll(".custom-dropdown").forEach((other) => {
              if (other !== dropdown) {
                other.classList.remove("custom-dropdown--open");
              }
            });

            dropdown.classList.toggle("custom-dropdown--open");
          });

          // Handle item selection
          items.forEach((item) => {
            item.addEventListener("click", async (e) => {
              e.stopPropagation();
              const newVersion = item.dataset.value;

              console.log(
                `Version changed for ${fontFamilyId} to ${newVersion}`
              );

              // Update UI
              items.forEach((i) =>
                i.classList.remove("custom-dropdown__item--selected")
              );
              item.classList.add("custom-dropdown__item--selected");
              valueDisplay.textContent = newVersion;

              // Close dropdown
              dropdown.classList.remove("custom-dropdown--open");

              // Find the toggle for this font family
              const toggle = document.querySelector(
                `.toggle__input[data-font-family-id="${fontFamilyId}"]`
              );

              if (toggle && toggle.checked) {
                // If toggle is ON, unregister the current font before changing version
                const currentFontId = toggle.dataset.currentFontId;
                console.log(
                  `Unregistering current font ${currentFontId} due to version change`
                );

                try {
                  const result = await window.fontAPI.unregisterFont(
                    currentFontId
                  );
                  if (result.success) {
                    registeredFontIds.delete(currentFontId);
                    console.log(
                      `Successfully unregistered font ${currentFontId}`
                    );
                  } else {
                    console.error(`Failed to unregister font: ${result.error}`);
                  }
                } catch (error) {
                  console.error("Error unregistering font:", error);
                }

                // Turn off the toggle
                toggle.checked = false;
                console.log(
                  `Disabled toggle for ${fontFamilyId} after unregistering`
                );
              }

              // Update the toggle's data attributes with new version info
              toggle.dataset.currentVersion = newVersion;
            });
          });
        });

        // Close dropdowns when clicking outside
        document.addEventListener("click", () => {
          document.querySelectorAll(".custom-dropdown").forEach((dropdown) => {
            dropdown.classList.remove("custom-dropdown--open");
          });
        });

        // Toggle switches - Font registration/unregistration
        const toggleInputs = document.querySelectorAll(".toggle__input");
        console.log("Found toggle inputs:", toggleInputs.length);

        toggleInputs.forEach((toggle, index) => {
          const fontFamilyId = toggle.dataset.fontFamilyId;
          console.log(
            `Setting up toggle ${index}, fontFamilyId:`,
            fontFamilyId
          );

          // Add click listener to the label for debugging
          const label = toggle.closest(".toggle");
          if (label) {
            label.addEventListener("click", (e) => {
              console.log("Label clicked for font family:", fontFamilyId);
            });
          }

          toggle.addEventListener("change", async (e) => {
            const target = e.target;
            const fontFamilyId = target.dataset.fontFamilyId;
            const isEnabled = target.checked;
            const currentVersion = target.dataset.currentVersion;

            console.log(
              "Toggle clicked:",
              fontFamilyId,
              isEnabled,
              "version:",
              currentVersion
            );

            // Find the font for the current version
            // We need to search through allFonts to find the right one
            const fontItem = target.closest(".font-item");
            const providerGroup = fontItem.closest(".provider-group");
            const providerId = providerGroup.dataset.providerId;

            // Find fonts matching this font family and version
            const matchingFonts = allFonts.filter((f) => {
              const fFormatSuffix = f.format === "opentype" ? "OTF" : "TTF";
              const fFamilyId = `${f.provider}-${(
                f.fontFamily || f.name
              ).replace(/\s+/g, "-")}-${fFormatSuffix}`;
              return fFamilyId === fontFamilyId && f.version === currentVersion;
            });

            if (matchingFonts.length === 0) {
              console.error(
                "No fonts found for:",
                fontFamilyId,
                currentVersion
              );
              target.checked = !isEnabled; // Revert
              return;
            }

            // Pick the first matching font (prefer TTF over OTF)
            const font =
              matchingFonts.find((f) => f.format === "truetype") ||
              matchingFonts[0];
            console.log("Selected font:", font);

            // Disable toggle during operation
            target.disabled = true;

            try {
              if (isEnabled) {
                // Register font
                console.log("Registering font:", font.name, font.downloadUrl);
                const result = await window.fontAPI.registerFont(
                  font.id,
                  font.downloadUrl,
                  font.name
                );

                console.log("Register result:", result);

                if (result.success) {
                  registeredFontIds.add(font.id);
                  target.dataset.currentFontId = font.id;
                  console.log("Font registered successfully:", font.name);
                } else {
                  throw new Error(result.error || "Registration failed");
                }
              } else {
                // Unregister font
                const fontIdToUnregister = target.dataset.currentFontId;
                console.log("Unregistering font:", fontIdToUnregister);
                const result = await window.fontAPI.unregisterFont(
                  fontIdToUnregister
                );

                console.log("Unregister result:", result);

                if (result.success) {
                  registeredFontIds.delete(fontIdToUnregister);
                  console.log("Font unregistered successfully");
                } else {
                  throw new Error(result.error || "Unregistration failed");
                }
              }
            } catch (error) {
              console.error("Font toggle error:", error);
              alert(
                `폰트 ${isEnabled ? "등록" : "해제"} 실패:\n${error.message}`
              );
              // Revert toggle state
              target.checked = !isEnabled;
            } finally {
              // Re-enable toggle
              target.disabled = false;
            }
          });
        });

        // Info buttons
        const infoButtons = document.querySelectorAll(".font-item__info-btn");
        console.log("Found info buttons:", infoButtons.length);

        infoButtons.forEach((button) => {
          button.addEventListener("click", (e) => {
            e.stopPropagation();
            const fontId = e.currentTarget.dataset.fontId;
            const font = allFonts.find((f) => f.id === fontId);

            if (font) {
              alert(
                `폰트 정보:\n\n이름: ${font.name}\n크기: ${(
                  font.fileSize /
                  1024 /
                  1024
                ).toFixed(2)} MB`
              );
            }
          });
        });

        console.log("=== Event listeners setup complete ===");
      }

      // Load fonts from API
      async function loadFonts() {
        try {
          console.log("Loading fonts...");
          console.log("window.fontAPI:", window.fontAPI);

          if (!window.fontAPI) {
            throw new Error("fontAPI is not available");
          }

          // Fetch purchased fonts
          const purchasedFonts = await window.fontAPI.fetchFonts();
          console.log("Purchased fonts:", purchasedFonts);

          // Get registered fonts
          const registeredFonts = await window.fontAPI.getRegisteredFonts();
          console.log("Registered fonts:", registeredFonts);

          // Store registered font IDs
          registeredFontIds = new Set(registeredFonts.map((f) => f.id));

          // Store all fonts
          allFonts = purchasedFonts;

          // Load font faces dynamically
          await loadFontFaces(purchasedFonts);

          // Render fonts
          renderFonts(purchasedFonts);

          console.log(
            `Loaded ${purchasedFonts.length} fonts, ${registeredFontIds.size} registered`
          );
        } catch (error) {
          console.error("Failed to load fonts:", error);
          alert(`폰트 목록을 불러오는데 실패했습니다.\n${error.message}`);
        }
      }

      // Load font faces dynamically using @font-face
      async function loadFontFaces(fonts) {
        const style = document.createElement("style");
        let css = "";
        const loadedFamilies = new Set();

        fonts.forEach((font) => {
          // Extract font family name from font name (remove weight/style info)
          const fontFamily = font.name
            .replace(/\s+(Regular|Bold|Light|Medium|Italic|Normal)$/i, "")
            .trim();

          // Create @font-face rule for each font
          css += `
            @font-face {
              font-family: '${fontFamily}';
              src: url('${font.downloadUrl}');
              font-display: swap;
            }
          `;

          // Also load preview font for provider if available
          if (font.previewFont && font.provider) {
            const previewFontFamily = font.previewFont.replace(
              /\.(ttf|otf)$/i,
              ""
            );

            // Only add once per provider
            if (!loadedFamilies.has(previewFontFamily)) {
              loadedFamilies.add(previewFontFamily);

              // Find the preview font file in the fonts array
              const previewFontFile = fonts.find(
                (f) =>
                  f.provider === font.provider &&
                  f.downloadUrl.includes(font.previewFont)
              );

              if (previewFontFile) {
                css += `
                  @font-face {
                    font-family: '${previewFontFamily}';
                    src: url('${previewFontFile.downloadUrl}');
                    font-display: swap;
                  }
                `;
              }
            }
          }
        });

        style.textContent = css;
        document.head.appendChild(style);
        console.log(`Loaded ${fonts.length} font faces`);
      }

      // Initialize
      document.addEventListener("DOMContentLoaded", () => {
        console.log("DOM loaded");
        loadFonts();
      });
    </script>
  </body>
</html>
