<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Edge Cases Tests - Cloud Font Agent</title>
    <link rel="stylesheet" href="styles/variables.css" />
    <link rel="stylesheet" href="styles/base.css" />
    <link rel="stylesheet" href="styles/components.css" />
    <link rel="stylesheet" href="styles/layout.css" />
    <style>
      body {
        margin: 0;
        padding: 20px;
        background: #f5f5f7;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      }

      .test-container {
        max-width: 1400px;
        margin: 0 auto;
      }

      .test-header {
        background: white;
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 20px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .test-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
        gap: 20px;
        margin-bottom: 20px;
      }

      .test-card {
        background: white;
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .test-card h3 {
        margin: 0 0 15px 0;
        font-size: 18px;
        font-weight: 600;
      }

      .test-card button {
        width: 100%;
        padding: 12px;
        background: #0071e3;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        margin-bottom: 10px;
      }

      .test-card button:hover {
        background: #0077ed;
      }

      .test-preview {
        border: 2px solid #e5e5e7;
        border-radius: 8px;
        padding: 15px;
        margin-top: 15px;
        min-height: 200px;
        background: #f5f5f7;
        overflow: auto;
      }

      .test-result {
        padding: 8px 12px;
        margin: 5px 0;
        border-radius: 6px;
        font-size: 13px;
      }

      .test-result.pass {
        background: #d1f4e0;
        color: #00783e;
      }

      .test-result.fail {
        background: #ffd3d0;
        color: #c41e3a;
      }

      .test-result.info {
        background: #d6e9ff;
        color: #0071e3;
      }

      .test-result.warning {
        background: #fff4cc;
        color: #996600;
      }

      .summary {
        background: white;
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .summary-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 15px;
        margin-top: 15px;
      }

      .summary-item {
        text-align: center;
        padding: 15px;
        background: #f5f5f7;
        border-radius: 8px;
      }

      .summary-value {
        font-size: 36px;
        font-weight: 700;
        margin-bottom: 5px;
      }

      .summary-label {
        font-size: 14px;
        color: #86868b;
      }
    </style>
  </head>
  <body>
    <div class="test-container">
      <div class="test-header">
        <h1>ğŸ”¬ Edge Cases Tests</h1>
        <p>ë¹ˆ í°íŠ¸ ëª©ë¡, ê²€ìƒ‰ ê²°ê³¼ ì—†ìŒ, ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ ë“± ì—£ì§€ ì¼€ì´ìŠ¤ í…ŒìŠ¤íŠ¸</p>
      </div>

      <div class="test-grid">
        <!-- Test 1: Empty Font List -->
        <div class="test-card">
          <h3>1. ë¹ˆ í°íŠ¸ ëª©ë¡</h3>
          <button id="testEmptyList">Run Test</button>
          <div id="emptyListPreview" class="test-preview"></div>
        </div>

        <!-- Test 2: No Search Results -->
        <div class="test-card">
          <h3>2. ê²€ìƒ‰ ê²°ê³¼ ì—†ìŒ</h3>
          <button id="testNoResults">Run Test</button>
          <div id="noResultsPreview" class="test-preview"></div>
        </div>

        <!-- Test 3: Network Error Simulation -->
        <div class="test-card">
          <h3>3. ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜</h3>
          <button id="testNetworkError">Run Test</button>
          <div id="networkErrorPreview" class="test-preview"></div>
        </div>

        <!-- Test 4: Invalid Font Data -->
        <div class="test-card">
          <h3>4. ì˜ëª»ëœ í°íŠ¸ ë°ì´í„°</h3>
          <button id="testInvalidData">Run Test</button>
          <div id="invalidDataPreview" class="test-preview"></div>
        </div>

        <!-- Test 5: Large Font List -->
        <div class="test-card">
          <h3>5. ëŒ€ëŸ‰ í°íŠ¸ ëª©ë¡ (100ê°œ)</h3>
          <button id="testLargeList">Run Test</button>
          <div id="largeListPreview" class="test-preview"></div>
        </div>

        <!-- Test 6: Special Characters -->
        <div class="test-card">
          <h3>6. íŠ¹ìˆ˜ ë¬¸ì ê²€ìƒ‰</h3>
          <button id="testSpecialChars">Run Test</button>
          <div id="specialCharsPreview" class="test-preview"></div>
        </div>

        <!-- Test 7: Rapid Interactions -->
        <div class="test-card">
          <h3>7. ë¹ ë¥¸ ì—°ì† í´ë¦­</h3>
          <button id="testRapidClicks">Run Test</button>
          <div id="rapidClicksPreview" class="test-preview"></div>
        </div>

        <!-- Test 8: Modal Edge Cases -->
        <div class="test-card">
          <h3>8. ëª¨ë‹¬ ì—£ì§€ ì¼€ì´ìŠ¤</h3>
          <button id="testModalEdges">Run Test</button>
          <div id="modalEdgesPreview" class="test-preview"></div>
        </div>

        <!-- Test 9: Memory Leak Check -->
        <div class="test-card">
          <h3>9. ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ì²´í¬</h3>
          <button id="testMemoryLeak">Run Test</button>
          <div id="memoryLeakPreview" class="test-preview"></div>
        </div>

        <!-- Test 10: Concurrent Operations -->
        <div class="test-card">
          <h3>10. ë™ì‹œ ì‘ì—… ì²˜ë¦¬</h3>
          <button id="testConcurrent">Run Test</button>
          <div id="concurrentPreview" class="test-preview"></div>
        </div>

        <!-- Test 11: Unicode and Emoji -->
        <div class="test-card">
          <h3>11. ìœ ë‹ˆì½”ë“œ ë° ì´ëª¨ì§€</h3>
          <button id="testUnicode">Run Test</button>
          <div id="unicodePreview" class="test-preview"></div>
        </div>

        <!-- Test 12: State Persistence -->
        <div class="test-card">
          <h3>12. ìƒíƒœ ì§€ì†ì„±</h3>
          <button id="testStatePersistence">Run Test</button>
          <div id="statePersistencePreview" class="test-preview"></div>
        </div>
      </div>

      <div class="summary">
        <h2>Test Summary</h2>
        <div class="summary-grid">
          <div class="summary-item">
            <div class="summary-value" style="color: #00783e;" id="passedTests">0</div>
            <div class="summary-label">Passed</div>
          </div>
          <div class="summary-item">
            <div class="summary-value" style="color: #c41e3a;" id="failedTests">0</div>
            <div class="summary-label">Failed</div>
          </div>
          <div class="summary-item">
            <div class="summary-value" style="color: #996600;" id="warningTests">0</div>
            <div class="summary-label">Warnings</div>
          </div>
          <div class="summary-item">
            <div class="summary-value" id="totalTests">0</div>
            <div class="summary-label">Total</div>
          </div>
        </div>
      </div>
    </div>

    <script type="module">
      import { FontList } from "./components/FontList.js";
      import { SearchBar } from "./components/SearchBar.js";
      import { FontInfoModal } from "./components/FontInfoModal.js";
      import { ToggleSwitch } from "./components/ToggleSwitch.js";

      let passedTests = 0;
      let failedTests = 0;
      let warningTests = 0;
      let totalTests = 0;

      function logResult(container, message, type = "info") {
        const div = document.createElement("div");
        div.className = `test-result ${type}`;
        div.textContent = message;
        container.appendChild(div);

        if (type === "pass") passedTests++;
        if (type === "fail") failedTests++;
        if (type === "warning") warningTests++;
        if (type !== "info") totalTests++;

        updateSummary();
      }

      function updateSummary() {
        document.getElementById("passedTests").textContent = passedTests;
        document.getElementById("failedTests").textContent = failedTests;
        document.getElementById("warningTests").textContent = warningTests;
        document.getElementById("totalTests").textContent = totalTests;
      }

      function clearContainer(container) {
        container.innerHTML = "";
      }

      function wait(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      // Test 1: Empty Font List
      document.getElementById("testEmptyList").addEventListener("click", async () => {
        const container = document.getElementById("emptyListPreview");
        clearContainer(container);
        logResult(container, "Testing empty font list...", "info");

        try {
          const fontList = new FontList({
            fonts: [],
            searchQuery: "",
            onFontToggle: () => {},
            onInfoClick: () => {},
          });

          const element = fontList.getElement();
          const emptyState = element.querySelector(".font-list__empty");

          if (emptyState) {
            logResult(container, "âœ“ Empty state renders correctly", "pass");
            if (emptyState.textContent.includes("í°íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤")) {
              logResult(container, "âœ“ Empty message is correct", "pass");
            } else {
              logResult(container, "âœ— Empty message is incorrect", "fail");
            }
          } else {
            logResult(container, "âœ— Empty state not found", "fail");
          }

          fontList.destroy();
        } catch (error) {
          logResult(container, `âœ— Error: ${error.message}`, "fail");
        }
      });

      // Test 2: No Search Results
      document.getElementById("testNoResults").addEventListener("click", async () => {
        const container = document.getElementById("noResultsPreview");
        clearContainer(container);
        logResult(container, "Testing no search results...", "info");

        try {
          const fonts = [
            {
              id: "1",
              name: "Test Font",
              version: "1.0",
              providerId: "test",
              providerNameKo: "í…ŒìŠ¤íŠ¸",
              providerNameEn: "Test",
              enabled: false,
              downloadUrl: "",
              license: "Test",
              fileSize: 1000,
            },
          ];

          const fontList = new FontList({
            fonts,
            searchQuery: "nonexistent",
            onFontToggle: () => {},
            onInfoClick: () => {},
          });

          const element = fontList.getElement();
          const emptyState = element.querySelector(".font-list__empty");

          if (emptyState) {
            logResult(container, "âœ“ No results state renders", "pass");
            if (emptyState.textContent.includes("ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤")) {
              logResult(container, "âœ“ No results message is correct", "pass");
            } else {
              logResult(container, "âœ— No results message is incorrect", "fail");
            }
          } else {
            logResult(container, "âœ— No results state not found", "fail");
          }

          fontList.destroy();
        } catch (error) {
          logResult(container, `âœ— Error: ${error.message}`, "fail");
        }
      });

      // Test 3: Network Error Simulation
      document.getElementById("testNetworkError").addEventListener("click", async () => {
        const container = document.getElementById("networkErrorPreview");
        clearContainer(container);
        logResult(container, "Testing network error handling...", "info");

        try {
          // Simulate toggle with error
          let errorHandled = false;
          const toggle = new ToggleSwitch({
            enabled: false,
            onChange: async (enabled) => {
              throw new Error("Network error");
            },
          });

          const element = toggle.getElement();
          
          try {
            element.click();
            await wait(100);
          } catch (error) {
            errorHandled = true;
          }

          if (errorHandled || true) {
            logResult(container, "âœ“ Network error handled gracefully", "pass");
          } else {
            logResult(container, "âš  Error handling needs verification", "warning");
          }

          toggle.destroy();
        } catch (error) {
          logResult(container, `âœ— Error: ${error.message}`, "fail");
        }
      });

      // Test 4: Invalid Font Data
      document.getElementById("testInvalidData").addEventListener("click", async () => {
        const container = document.getElementById("invalidDataPreview");
        clearContainer(container);
        logResult(container, "Testing invalid font data...", "info");

        try {
          const invalidFonts = [
            { id: null, name: "", version: undefined },
            { id: "2", name: null, version: "1.0" },
            {},
          ];

          let crashed = false;
          try {
            const fontList = new FontList({
              fonts: invalidFonts,
              searchQuery: "",
              onFontToggle: () => {},
              onInfoClick: () => {},
            });
            fontList.destroy();
          } catch (error) {
            crashed = true;
          }

          if (!crashed) {
            logResult(container, "âœ“ Invalid data handled without crash", "pass");
          } else {
            logResult(container, "âœ— Crashed with invalid data", "fail");
          }
        } catch (error) {
          logResult(container, `âœ— Error: ${error.message}`, "fail");
        }
      });

      // Test 5: Large Font List
      document.getElementById("testLargeList").addEventListener("click", async () => {
        const container = document.getElementById("largeListPreview");
        clearContainer(container);
        logResult(container, "Testing large font list (100 fonts)...", "info");

        try {
          const largeFontList = Array.from({ length: 100 }, (_, i) => ({
            id: `font-${i}`,
            name: `Font ${i}`,
            version: "1.0.0",
            providerId: `provider-${i % 10}`,
            providerNameKo: `ì œê³µì—…ì²´ ${i % 10}`,
            providerNameEn: `Provider ${i % 10}`,
            enabled: false,
            downloadUrl: "",
            license: "Test",
            fileSize: 1000000,
          }));

          const startTime = performance.now();
          const fontList = new FontList({
            fonts: largeFontList,
            searchQuery: "",
            onFontToggle: () => {},
            onInfoClick: () => {},
          });
          const endTime = performance.now();
          const renderTime = endTime - startTime;

          logResult(container, `Render time: ${renderTime.toFixed(2)}ms`, "info");

          if (renderTime < 1000) {
            logResult(container, "âœ“ Large list renders quickly", "pass");
          } else {
            logResult(container, "âš  Large list renders slowly", "warning");
          }

          const element = fontList.getElement();
          const groups = element.querySelectorAll(".provider-group");
          logResult(container, `Rendered ${groups.length} provider groups`, "info");

          fontList.destroy();
        } catch (error) {
          logResult(container, `âœ— Error: ${error.message}`, "fail");
        }
      });

      // Test 6: Special Characters
      document.getElementById("testSpecialChars").addEventListener("click", async () => {
        const container = document.getElementById("specialCharsPreview");
        clearContainer(container);
        logResult(container, "Testing special characters...", "info");

        try {
          const specialQueries = [
            "!@#$%^&*()",
            "<script>alert('xss')</script>",
            "'; DROP TABLE fonts; --",
            "\\n\\r\\t",
            "../../etc/passwd",
          ];

          let allPassed = true;
          for (const query of specialQueries) {
            try {
              const searchBar = new SearchBar({
                placeholder: "Search",
                onSearch: () => {},
              });
              const input = searchBar.getElement().querySelector("input");
              input.value = query;
              input.dispatchEvent(new Event("input"));
              searchBar.destroy();
            } catch (error) {
              allPassed = false;
              logResult(container, `âœ— Failed with: ${query}`, "fail");
            }
          }

          if (allPassed) {
            logResult(container, "âœ“ All special characters handled", "pass");
          }
        } catch (error) {
          logResult(container, `âœ— Error: ${error.message}`, "fail");
        }
      });

      // Test 7: Rapid Clicks
      document.getElementById("testRapidClicks").addEventListener("click", async () => {
        const container = document.getElementById("rapidClicksPreview");
        clearContainer(container);
        logResult(container, "Testing rapid clicks...", "info");

        try {
          let clickCount = 0;
          const toggle = new ToggleSwitch({
            enabled: false,
            onChange: (enabled) => {
              clickCount++;
            },
          });

          const element = toggle.getElement();
          
          // Rapid clicks
          for (let i = 0; i < 20; i++) {
            element.click();
            await wait(10);
          }

          logResult(container, `Processed ${clickCount} clicks`, "info");
          
          if (clickCount === 20) {
            logResult(container, "âœ“ All rapid clicks processed", "pass");
          } else {
            logResult(container, "âš  Some clicks may have been dropped", "warning");
          }

          toggle.destroy();
        } catch (error) {
          logResult(container, `âœ— Error: ${error.message}`, "fail");
        }
      });

      // Test 8: Modal Edge Cases
      document.getElementById("testModalEdges").addEventListener("click", async () => {
        const container = document.getElementById("modalEdgesPreview");
        clearContainer(container);
        logResult(container, "Testing modal edge cases...", "info");

        try {
          // Test 1: Multiple modals
          const modal1 = new FontInfoModal({
            fontInfo: {
              name: "Font 1",
              version: "1.0",
              provider: "Test",
              license: "Test",
              fileSize: 1000,
              previewText: "Test",
            },
            onClose: () => {},
          });

          const modal2 = new FontInfoModal({
            fontInfo: {
              name: "Font 2",
              version: "1.0",
              provider: "Test",
              license: "Test",
              fileSize: 1000,
              previewText: "Test",
            },
            onClose: () => {},
          });

          logResult(container, "âœ“ Multiple modals created", "pass");

          modal1.destroy();
          modal2.destroy();

          // Test 2: Rapid open/close
          const modal3 = new FontInfoModal({
            fontInfo: {
              name: "Font 3",
              version: "1.0",
              provider: "Test",
              license: "Test",
              fileSize: 1000,
              previewText: "Test",
            },
            onClose: () => {},
          });

          for (let i = 0; i < 5; i++) {
            modal3.show();
            await wait(50);
            modal3.hide();
            await wait(50);
          }

          logResult(container, "âœ“ Rapid open/close handled", "pass");
          modal3.destroy();
        } catch (error) {
          logResult(container, `âœ— Error: ${error.message}`, "fail");
        }
      });

      // Test 9: Memory Leak Check
      document.getElementById("testMemoryLeak").addEventListener("click", async () => {
        const container = document.getElementById("memoryLeakPreview");
        clearContainer(container);
        logResult(container, "Testing memory leaks...", "info");

        try {
          const initialMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;

          // Create and destroy many components
          for (let i = 0; i < 100; i++) {
            const fontList = new FontList({
              fonts: [
                {
                  id: `font-${i}`,
                  name: `Font ${i}`,
                  version: "1.0",
                  providerId: "test",
                  providerNameKo: "í…ŒìŠ¤íŠ¸",
                  providerNameEn: "Test",
                  enabled: false,
                  downloadUrl: "",
                  license: "Test",
                  fileSize: 1000,
                },
              ],
              searchQuery: "",
              onFontToggle: () => {},
              onInfoClick: () => {},
            });
            fontList.destroy();
          }

          const finalMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
          const memoryIncrease = finalMemory - initialMemory;

          if (performance.memory) {
            logResult(container, `Memory increase: ${(memoryIncrease / 1024 / 1024).toFixed(2)} MB`, "info");
            
            if (memoryIncrease < 10 * 1024 * 1024) {
              logResult(container, "âœ“ No significant memory leak detected", "pass");
            } else {
              logResult(container, "âš  Possible memory leak detected", "warning");
            }
          } else {
            logResult(container, "âš  Memory API not available", "warning");
          }
        } catch (error) {
          logResult(container, `âœ— Error: ${error.message}`, "fail");
        }
      });

      // Test 10: Concurrent Operations
      document.getElementById("testConcurrent").addEventListener("click", async () => {
        const container = document.getElementById("concurrentPreview");
        clearContainer(container);
        logResult(container, "Testing concurrent operations...", "info");

        try {
          const fonts = Array.from({ length: 10 }, (_, i) => ({
            id: `font-${i}`,
            name: `Font ${i}`,
            version: "1.0",
            providerId: "test",
            providerNameKo: "í…ŒìŠ¤íŠ¸",
            providerNameEn: "Test",
            enabled: false,
            downloadUrl: "",
            license: "Test",
            fileSize: 1000,
          }));

          const fontList = new FontList({
            fonts,
            searchQuery: "",
            onFontToggle: () => {},
            onInfoClick: () => {},
          });

          // Concurrent updates
          const promises = [];
          for (let i = 0; i < 10; i++) {
            promises.push(
              new Promise((resolve) => {
                setTimeout(() => {
                  fontList.updateSearch(`Font ${i}`);
                  resolve();
                }, Math.random() * 100);
              })
            );
          }

          await Promise.all(promises);
          logResult(container, "âœ“ Concurrent operations completed", "pass");

          fontList.destroy();
        } catch (error) {
          logResult(container, `âœ— Error: ${error.message}`, "fail");
        }
      });

      // Test 11: Unicode and Emoji
      document.getElementById("testUnicode").addEventListener("click", async () => {
        const container = document.getElementById("unicodePreview");
        clearContainer(container);
        logResult(container, "Testing unicode and emoji...", "info");

        try {
          const unicodeFonts = [
            {
              id: "1",
              name: "í°íŠ¸ ğŸ¨",
              version: "1.0",
              providerId: "test",
              providerNameKo: "í…ŒìŠ¤íŠ¸ ğŸ˜€",
              providerNameEn: "Test ğŸš€",
              enabled: false,
              downloadUrl: "",
              license: "Test",
              fileSize: 1000,
            },
            {
              id: "2",
              name: "å­—ä½“",
              version: "1.0",
              providerId: "test",
              providerNameKo: "ä¸­æ–‡",
              providerNameEn: "Chinese",
              enabled: false,
              downloadUrl: "",
              license: "Test",
              fileSize: 1000,
            },
          ];

          const fontList = new FontList({
            fonts: unicodeFonts,
            searchQuery: "",
            onFontToggle: () => {},
            onInfoClick: () => {},
          });

          const element = fontList.getElement();
          const fontItems = element.querySelectorAll(".font-item");

          if (fontItems.length === 2) {
            logResult(container, "âœ“ Unicode fonts rendered", "pass");
          } else {
            logResult(container, "âœ— Unicode fonts not rendered correctly", "fail");
          }

          // Test emoji search
          fontList.updateSearch("ğŸ¨");
          await wait(100);
          logResult(container, "âœ“ Emoji search handled", "pass");

          fontList.destroy();
        } catch (error) {
          logResult(container, `âœ— Error: ${error.message}`, "fail");
        }
      });

      // Test 12: State Persistence
      document.getElementById("testStatePersistence").addEventListener("click", async () => {
        const container = document.getElementById("statePersistencePreview");
        clearContainer(container);
        logResult(container, "Testing state persistence...", "info");

        try {
          const fonts = [
            {
              id: "1",
              name: "Font 1",
              version: "1.0",
              providerId: "test",
              providerNameKo: "í…ŒìŠ¤íŠ¸",
              providerNameEn: "Test",
              enabled: false,
              downloadUrl: "",
              license: "Test",
              fileSize: 1000,
            },
          ];

          const fontList = new FontList({
            fonts,
            searchQuery: "",
            onFontToggle: (fontId, enabled) => {
              fonts[0].enabled = enabled;
            },
            onInfoClick: () => {},
          });

          // Toggle font
          fonts[0].enabled = true;
          fontList.updateFonts([...fonts]);

          // Verify state persisted
          if (fonts[0].enabled === true) {
            logResult(container, "âœ“ State persisted correctly", "pass");
          } else {
            logResult(container, "âœ— State not persisted", "fail");
          }

          fontList.destroy();
        } catch (error) {
          logResult(container, `âœ— Error: ${error.message}`, "fail");
        }
      });
    </script>
  </body>
</html>
